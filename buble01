<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>버블 슈터 게임</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #333;
            flex-direction: column;
            font-family: Arial, sans-serif;
            touch-action: none; /* 모바일 스크롤 방지 */
        }
        canvas {
            border: 5px solid #0044aa;
            background-color: #e0f7fa;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        #info {
            color: white;
            margin-bottom: 10px;
            font-size: 1.2em;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="info">
        점수: <span id="score">0</span> | 남은 행: <span id="remainingRows"></span>
        <div id="message" style="color: yellow; margin-top: 5px;"></div>
    </div>
    <canvas id="gameCanvas" width="400" height="600"></canvas>

    <script>
        // HTML 요소 및 Canvas 컨텍스트
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const remainingRowsDisplay = document.getElementById('remainingRows');
        const messageDisplay = document.getElementById('message');

        // ====== 상수 및 설정 ======
        const CANVAS_WIDTH = canvas.width;
        const CANVAS_HEIGHT = canvas.height;
        const BUBBLE_RADIUS = 20; // 버블 크기를 20으로 조정하여 시인성 높임
        const BUBBLE_COLORS = ['red', 'green', 'blue', 'yellow', 'purple'];
        const SHOOTER_Y = CANVAS_HEIGHT - BUBBLE_RADIUS * 2;
        const GRID_ROWS = 15; // 총 행 수
        const GRID_COLS = 10; // 짝수 행의 열 수
        const ROW_HEIGHT = Math.sqrt(3) * BUBBLE_RADIUS; // 정육각형 배치 높이

        // ====== 전역 변수 ======
        let score = 0;
        let isGameOver = false;
        let currentBubble;
        let firedBubble = null;
        let bubbleGrid = [];
        let gameLoop;

        // ====== 클래스 정의: Bubble ======
        class Bubble {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.radius = BUBBLE_RADIUS;
                this.color = color;
                this.vx = 0;
                this.vy = 0;
                this.isFired = false;
                this.isMatched = false;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.closePath();
            }

            update() {
                if (this.isFired) {
                    this.x += this.vx;
                    this.y += this.vy;
                }
            }
        }
        
        // ====== 게임 초기화 및 그리드 설정 ======
        
        function getRandomColor(availableColors) {
            return availableColors[Math.floor(Math.random() * availableColors.length)];
        }
        
        function getRandomBubble() {
            // 현재 그리드에 존재하는 색상만 발사되도록 제한
            let activeColors = new Set();
            bubbleGrid.forEach(row => {
                row.forEach(b => {
                    if (b) activeColors.add(b.color);
                });
            });
            let colorsArray = Array.from(activeColors.size > 0 ? activeColors : BUBBLE_COLORS);

            const randomColor = getRandomColor(colorsArray);
            return new Bubble(CANVAS_WIDTH / 2, SHOOTER_Y, randomColor);
        }

        /**
         * 게임판 상단에 초기 버블 그리드를 생성합니다.
         */
        function initGrid() {
            bubbleGrid = [];
            for (let r = 0; r < GRID_ROWS; r++) {
                bubbleGrid[r] = [];
                // 홀수 행은 반 칸 오프셋
                const offsetX = (r % 2 === 1) ? BUBBLE_RADIUS : 0; 
                const colsInRow = GRID_COLS - (r % 2);
                
                for (let c = 0; c < colsInRow; c++) {
                    const x = c * BUBBLE_RADIUS * 2 + BUBBLE_RADIUS + offsetX;
                    const y = r * ROW_HEIGHT + BUBBLE_RADIUS;

                    if (r < 5) { // 처음 5줄만 버블 채우기
                        const randomColor = getRandomColor(BUBBLE_COLORS.slice(0, 4)); // 4가지 색상만 사용
                        bubbleGrid[r][c] = new Bubble(x, y, randomColor);
                    } else {
                        bubbleGrid[r][c] = null;
                    }
                }
            }
        }

        function startGame() {
            cancelAnimationFrame(gameLoop);
            score = 0;
            isGameOver = false;
            firedBubble = null;
            messageDisplay.textContent = "";

            initGrid();
            currentBubble = getRandomBubble();
            scoreDisplay.textContent = score;
            requestAnimationFrame(draw);
        }
        
        // ====== 발사 로직 ======

        function shootBubble(targetX, targetY) {
            if (isGameOver || firedBubble) return;

            let dx = targetX - currentBubble.x;
            let dy = targetY - currentBubble.y;
            
            // 위로 발사되는지 확인 (아래로 발사 방지)
            if (dy > 0) return;

            // 속도(벡터) 정규화 및 속력 적용
            const magnitude = Math.sqrt(dx * dx + dy * dy);
            const speed = 8;
            currentBubble.vx = (dx / magnitude) * speed;
            currentBubble.vy = (dy / magnitude) * speed;
            
            currentBubble.isFired = true;
            firedBubble = currentBubble;
            
            // 다음 발사 버블 준비
            currentBubble = getRandomBubble(); 
        }

        // ====== 충돌 및 고정 로직 (핵심) ======

        /**
         * 발사된 버블이 그리드의 버블과 충돌했는지 검사합니다.
         */
        function checkGridCollision(bubble) {
            // 천장 충돌 검사
            if (bubble.y - BUBBLE_RADIUS <= 0) {
                return true;
            }

            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < bubbleGrid[r].length; c++) {
                    const target = bubbleGrid[r][c];
                    if (target) {
                        // 두 버블 간의 거리 계산
                        const distance = Math.sqrt(
                            (bubble.x - target.x) ** 2 + (bubble.y - target.y) ** 2
                        );
                        // 거리가 반지름 합보다 작거나 같으면 충돌
                        if (distance < BUBBLE_RADIUS * 2) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        /**
         * 충돌한 버블을 가장 가까운 그리드 위치에 고정합니다.
         */
        function snapBubbleToGrid(bubble) {
            // 1. 가장 가까운 행(r)과 열(c) 인덱스 계산
            const r = Math.round((bubble.y - BUBBLE_RADIUS) / ROW_HEIGHT);
            const cFloat = (bubble.x - BUBBLE_RADIUS) / (BUBBLE_RADIUS * 2) - (r % 2 === 1 ? 0.5 : 0);
            let c = Math.round(cFloat);

            // 2. 인덱스 유효성 검사 및 조정
            if (r < 0) r = 0;
            if (r >= GRID_ROWS) r = GRID_ROWS - 1; 

            // 행의 최대 열 수에 맞춰 c 조정
            const colsInRow = GRID_COLS - (r % 2);
            if (c < 0) c = 0;
            if (c >= colsInRow) c = colsInRow - 1;

            // 3. 실제 좌표로 위치 보정 (스냅)
            const offsetX = (r % 2 === 1) ? BUBBLE_RADIUS : 0;
            bubble.x = c * BUBBLE_RADIUS * 2 + BUBBLE_RADIUS + offsetX;
            bubble.y = r * ROW_HEIGHT + BUBBLE_RADIUS;
            
            // 4. 그리드에 추가
            if (bubbleGrid[r] && bubbleGrid[r][c] === null) {
                bubbleGrid[r][c] = bubble;
            } else {
                // 이미 자리가 찼다면 주변 가장 가까운 빈 공간을 찾아야 함 (복잡도 증가로 생략)
                // 현재는 충돌 감지가 완벽하지 않아 발생할 수 있음. 
                // 간단히 현재 위치에 스냅 후 처리.
                bubbleGrid[r][c] = bubble; 
            }
            
            // 5. 발사 버블 해제
            firedBubble = null;
            
            // 6. 매칭 및 제거 로직 실행
            checkAndClearMatches(r, c);
        }

        // ====== 매칭 및 제거 로직 ======

        /**
         * 특정 위치 (r, c)의 버블을 시작으로 인접한 같은 색 버블을 찾습니다.
         */
        function findNeighbors(r, c) {
            // 정육각형 격자의 이웃 인덱스 오프셋
            const isOddRow = r % 2 !== 0; // 홀수 행인지 확인

            // 오프셋: [dr, dc]
            const offsets = isOddRow ? [
                [-1, 0], [-1, 1], // 위 왼쪽, 위 오른쪽
                [0, -1], [0, 1],  // 좌, 우
                [1, 0], [1, 1]    // 아래 왼쪽, 아래 오른쪽
            ] : [
                [-1, -1], [-1, 0], // 위 왼쪽, 위 오른쪽
                [0, -1], [0, 1],   // 좌, 우
                [1, -1], [1, 0]    // 아래 왼쪽, 아래 오른쪽
            ];

            const neighbors = [];
            offsets.forEach(([dr, dc]) => {
                const nr = r + dr;
                const nc = c + dc;

                if (nr >= 0 && nr < GRID_ROWS && nc >= 0 && nc < bubbleGrid[nr].length) {
                    if (bubbleGrid[nr][nc]) {
                        neighbors.push({ r: nr, c: nc, bubble: bubbleGrid[nr][nc] });
                    }
                }
            });
            return neighbors;
        }

        /**
         * 너비 우선 탐색 (BFS)을 사용하여 연결된 같은 색 버블을 모두 찾습니다.
         */
        function getConnectedBubbles(startR, startC, targetColor, checkMatchOnly = true) {
            const queue = [{ r: startR, c: startC }];
            const visited = new Set();
            const connected = [];

            while (queue.length > 0) {
                const { r, c } = queue.shift();
                const key = `${r},${c}`;

                if (visited.has(key)) continue;
                visited.add(key);

                const bubble = bubbleGrid[r][c];
                if (bubble && bubble.color === targetColor) {
                    connected.push({ r, c });

                    // 인접 버블 탐색
                    findNeighbors(r, c).forEach(neighbor => {
                        if (!visited.has(`${neighbor.r},${neighbor.c}`) && 
                            neighbor.bubble.color === targetColor) {
                            queue.push({ r: neighbor.r, c: neighbor.c });
                        }
                    });
                }
            }
            return connected;
        }

        /**
         * 매칭되는 버블을 제거하고, 떠 있는 버블을 제거하며, 점수를 계산합니다.
         */
        function checkAndClearMatches(r, c) {
            const startBubble = bubbleGrid[r][c];
            if (!startBubble) return;

            // 1. 같은 색상으로 연결된 모든 버블 찾기
            const connected = getConnectedBubbles(r, c, startBubble.color);
            
            if (connected.length >= 3) {
                // 3개 이상 연결 시 제거
                connected.forEach(({ r, c }) => {
                    bubbleGrid[r][c] = null;
                });
                score += connected.length * 10; // 점수 증가

                // 2. 고아 버블(Floating Bubbles) 제거 로직
                // (제거된 후 천장에 연결되지 않고 떠 있는 모든 버블 찾기)
                clearFloatingBubbles();
            } else {
                // 매치 실패 시, 다음 행이 내려와야 할 조건 검사 등 추가 가능
            }
            
            // 3. 게임 오버 조건 검사 (버블이 바닥까지 내려왔는지)
            checkGameOver();
        }

        /**
         * 천장에 닿아있지 않은 떠 있는 버블을 찾아 제거합니다.
         */
        function clearFloatingBubbles() {
            // 1. 천장에 직접 연결된 버블(Top Row)부터 시작하여 연결된 모든 버블을 BFS로 찾습니다.
            const connectedToTop = new Set();
            for (let c = 0; c < bubbleGrid[0].length; c++) {
                if (bubbleGrid[0][c]) {
                    // 천장 버블과 연결된 모든 버블 찾기 (색상 무관)
                    const queue = [{ r: 0, c: c }];
                    const visited = new Set();

                    while (queue.length > 0) {
                        const { r, c } = queue.shift();
                        const key = `${r},${c}`;

                        if (visited.has(key)) continue;
                        visited.add(key);

                        if (r >= 0 && r < GRID_ROWS && c >= 0 && c < bubbleGrid[r].length && bubbleGrid[r][c]) {
                            connectedToTop.add(key);
                            findNeighbors(r, c).forEach(neighbor => {
                                if (!visited.has(`${neighbor.r},${neighbor.c}`)) {
                                    queue.push({ r: neighbor.r, c: neighbor.c });
                                }
                            });
                        }
                    }
                }
            }

            // 2. 전체 그리드를 순회하며, 천장에 연결되지 않은 버블(고아 버블)을 제거합니다.
            let floatersRemoved = 0;
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < bubbleGrid[r].length; c++) {
                    const key = `${r},${c}`;
                    if (bubbleGrid[r][c] && !connectedToTop.has(key)) {
                        bubbleGrid[r][c] = null;
                        floatersRemoved++;
                    }
                }
            }
            
            if (floatersRemoved > 0) {
                score += floatersRemoved * 50; // 보너스 점수
                messageDisplay.textContent = `보너스! ${floatersRemoved}개의 버블이 떨어졌습니다.`;
            } else {
                messageDisplay.textContent = "";
            }
        }

        // ====== 게임 루프 및 업데이트 ======

        function handleFiredBubbleCollision() {
            if (!firedBubble) return;

            // 1. 좌우 벽 충돌 처리 (튀기기)
            if (firedBubble.x - BUBBLE_RADIUS < 0 || firedBubble.x + BUBBLE_RADIUS > CANVAS_WIDTH) {
                firedBubble.vx *= -1;
            }

            // 2. 천장/그리드 버블 충돌 처리
            if (firedBubble.y - BUBBLE_RADIUS <= 0 || checkGridCollision(firedBubble)) {
                snapBubbleToGrid(firedBubble);
            }
        }
        
        function checkGameOver() {
            // 바닥에서 일정 높이 이상 버블이 내려왔는지 확인
            const maxR = Math.floor(SHOOTER_Y / ROW_HEIGHT);

            for (let r = 0; r < GRID_ROWS; r++) {
                if (r > maxR && bubbleGrid[r].some(b => b !== null)) {
                    isGameOver = true;
                    messageDisplay.textContent = "게임 오버! 다시 시작하려면 클릭하세요.";
                    return;
                }
            }
            
            // 게임 승리 조건 (모든 버블 제거)
            if (bubbleGrid.every(row => row.every(b => b === null))) {
                isGameOver = true;
                messageDisplay.textContent = "★ 승리! 축하합니다! ★";
            }
        }

        function drawGrid() {
            let activeRows = 0;
            for (let r = 0; r < GRID_ROWS; r++) {
                // 게임 오버 조건 확인을 위해 활성화된 행 수 계산
                if (bubbleGrid[r].some(b => b !== null)) {
                    activeRows++;
                }

                for (let c = 0; c < bubbleGrid[r].length; c++) {
                    const bubble = bubbleGrid[r][c];
                    if (bubble) {
                        bubble.draw();
                    }
                }
            }
            remainingRowsDisplay.textContent = activeRows;
        }

        function draw() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // 게임 오버 시 루프 종료
            if (isGameOver) {
                return;
            }

            // 1. 발사대 버블 그리기
            currentBubble.draw();
            
            // 2. 발사된 버블 그리기 및 업데이트
            if (firedBubble) {
                firedBubble.update();
                firedBubble.draw();
                handleFiredBubbleCollision(); 
            }

            // 3. 고정된 버블 그리드 그리기
            drawGrid();
            scoreDisplay.textContent = score;

            gameLoop = requestAnimationFrame(draw); 
        }

        // ====== 이벤트 리스너 ======
        
        function handleInput(event) {
            if (isGameOver) {
                startGame();
                return;
            }

            let targetX, targetY;
            if (event.touches) { // 모바일 터치
                const rect = canvas.getBoundingClientRect();
                targetX = event.changedTouches[0].clientX - rect.left;
                targetY = event.changedTouches[0].clientY - rect.top;
            } else { // PC 마우스 클릭
                targetX = event.offsetX;
                targetY = event.offsetY;
            }
            
            shootBubble(targetX, targetY);
        }

        // PC 마우스 클릭 및 모바일 터치 이벤트
        canvas.addEventListener('click', handleInput);
        canvas.addEventListener('touchend', (e) => {
             e.preventDefault(); // 스크롤 방지
             handleInput(e);
        });
        
        // ====== 게임 시작 ======
        startGame();
    </script>
</body>
</html>
