<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÏûêÎèô Ï°∞Ï§Ä Î≤ÑÎ∏î ÏäàÌÑ∞</title>
    <style>
        /* Í∏∞Î≥∏ Ïä§ÌÉÄÏùº */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #1f4287, #21e4c7); 
            flex-direction: column;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; 
            padding: 10px;
        }

        #game-wrapper {
            background-color: #0d2c55; 
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), 0 0 10px rgba(255, 255, 255, 0.1);
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 420px; 
        }

        canvas {
            border: 4px solid #4a90e2; 
            background-color: #1a4e7e; 
            cursor: pointer;
            border-radius: 8px;
            width: 380px; 
            height: 570px; 
            margin-bottom: 15px;
        }
        
        #info {
            color: #ffffff;
            margin-bottom: 10px;
            font-size: 1.1em;
            font-weight: 600;
            width: 100%;
            text-align: center;
            background-color: #0b3a6d;
            padding: 8px 0;
            border-radius: 5px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        #message {
            color: #ffeb3b;
            font-size: 1.2em;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }

        #shooter {
            position: absolute;
            z-index: 10;
            color: #38c172; 
            font-size: 3em;
            text-shadow: 1px 1px 3px #000;
            pointer-events: none;
        }

        /* 2. Î™®Î∞îÏùº Î∞úÏÇ¨ Î≤ÑÌäº Ïä§ÌÉÄÏùº */
        #mobile-controls {
            width: 90%;
            max-width: 380px;
            display: flex;
            justify-content: center;
            margin-top: 5px;
        }

        #shoot-button {
            padding: 15px 30px;
            font-size: 1.4em;
            font-weight: bold;
            color: white;
            background-color: #e91e63; /* Í∞ïÎ†¨Ìïú Î∞úÏÇ¨ Î≤ÑÌäº ÏÉâÏÉÅ */
            border: none;
            border-radius: 8px;
            box-shadow: 0 4px #ad1457;
            cursor: pointer;
            user-select: none;
            transition: all 0.1s;
        }

        #shoot-button:active {
            box-shadow: 0 2px #ad1457;
            transform: translateY(2px);
        }
    </style>
</head>
<body>
    <div id="game-wrapper">
        <div id="info">
            Ï†êÏàò: <span id="score">0</span> | ÎÇ®ÏùÄ Ìñâ: <span id="remainingRows"></span>
            <div id="message"></div>
        </div>
        
        <canvas id="gameCanvas" width="400" height="600"></canvas>
        
        <div id="shooter">üê¢</div> 

        <div id="mobile-controls">
            <button id="shoot-button">Î∞úÏÇ¨!</button>
        </div>
    </div>

    <script>
        // HTML ÏöîÏÜå Î∞è Canvas Ïª®ÌÖçÏä§Ìä∏
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const remainingRowsDisplay = document.getElementById('remainingRows');
        const messageDisplay = document.getElementById('message');
        const shooterElement = document.getElementById('shooter');
        const shootButton = document.getElementById('shoot-button'); // Î∞úÏÇ¨ Î≤ÑÌäº DOM

        // ====== ÏÉÅÏàò Î∞è ÏÑ§Ï†ï ======
        const CANVAS_WIDTH = 400; 
        const CANVAS_HEIGHT = 600; 
        const BUBBLE_RADIUS = 20; 
        const BUBBLE_COLORS = ['#ff4c4c', '#4caf50', '#2196f3', '#ffeb3b', '#9c27b0'];
        const SHOOTER_Y = CANVAS_HEIGHT - BUBBLE_RADIUS * 2;
        const GRID_ROWS = 15; 
        const GRID_COLS = 10; 
        const ROW_HEIGHT = Math.sqrt(3) * BUBBLE_RADIUS; 
        
        // 1. ÏûêÎèô Ï°∞Ï§ÄÏùÑ ÏúÑÌïú Î≥ÄÏàò
        let aimAngle = Math.PI / 2;     // ÌòÑÏû¨ Í∞ÅÎèÑ (90ÎèÑ)
        let angleDirection = 1;         // 1: Ïò§Î•∏Ï™ΩÏúºÎ°ú, -1: ÏôºÏ™ΩÏúºÎ°ú
        const AIM_SPEED = 0.03;         // ÏûêÎèô ÏôïÎ≥µ ÏÜçÎèÑ

        const MIN_ANGLE = Math.PI / 8;  // ÏµúÏÜå Í∞ÅÎèÑ (ÏïΩ 22.5ÎèÑ)
        const MAX_ANGLE = Math.PI * 7 / 8; // ÏµúÎåÄ Í∞ÅÎèÑ (ÏïΩ 157.5ÎèÑ)

        // ====== Ï†ÑÏó≠ Î≥ÄÏàò ======
        let score = 0;
        let isGameOver = false;
        let currentBubble;
        let firedBubble = null;
        let bubbleGrid = [];
        let gameLoop;
        let isShooting = false; 

        // ====== ÌÅ¥ÎûòÏä§ Ï†ïÏùò: Bubble (Ïù¥Ï†ÑÍ≥º ÎèôÏùº) ======
        class Bubble {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.radius = BUBBLE_RADIUS;
                this.color = color;
                this.vx = 0;
                this.vy = 0;
                this.isFired = false;
                this.isMatched = false;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.closePath();
            }

            update() {
                if (this.isFired) {
                    this.x += this.vx;
                    this.y += this.vy;
                }
            }
        }
        
        // ====== Í≤åÏûÑ Ï¥àÍ∏∞Ìôî Î∞è ÏãúÏûë ======
        
        function getRandomColor(availableColors) {
            return availableColors[Math.floor(Math.random() * availableColors.length)];
        }
        
        function getRandomBubble() {
            let activeColors = new Set();
            bubbleGrid.forEach(row => {
                row.forEach(b => {
                    if (b) activeColors.add(b.color);
                });
            });
            let colorsArray = Array.from(activeColors.size > 0 ? activeColors : BUBBLE_COLORS);

            const randomColor = getRandomColor(colorsArray);
            return new Bubble(CANVAS_WIDTH / 2, SHOOTER_Y, randomColor);
        }

        function initGrid() {
            bubbleGrid = [];
            for (let r = 0; r < GRID_ROWS; r++) {
                bubbleGrid[r] = [];
                const offsetX = (r % 2 === 1) ? BUBBLE_RADIUS : 0; 
                const colsInRow = GRID_COLS - (r % 2);
                
                for (let c = 0; c < colsInRow; c++) {
                    const x = c * BUBBLE_RADIUS * 2 + BUBBLE_RADIUS + offsetX;
                    const y = r * ROW_HEIGHT + BUBBLE_RADIUS;

                    if (r < 5) { 
                        const randomColor = getRandomColor(BUBBLE_COLORS.slice(0, 4)); 
                        bubbleGrid[r][c] = new Bubble(x, y, randomColor);
                    } else {
                        bubbleGrid[r][c] = null;
                    }
                }
            }
        }

        function startGame() {
            cancelAnimationFrame(gameLoop);
            score = 0;
            isGameOver = false;
            firedBubble = null;
            messageDisplay.textContent = "Î∞©Ìñ• ÌôîÏÇ¥ÌëúÍ∞Ä ÏûêÎèôÏúºÎ°ú ÏõÄÏßÅÏûÖÎãàÎã§. Î∞úÏÇ¨ Î≤ÑÌäºÏù¥ÎÇò Ïä§ÌéòÏù¥Ïä§Î∞îÎ•º ÎàÑÎ•¥ÏÑ∏Ïöî!";

            initGrid();
            currentBubble = getRandomBubble();
            scoreDisplay.textContent = score;
            
            updateShooterPosition();
            
            requestAnimationFrame(draw);
        }
        
        function updateShooterPosition() {
            const rect = canvas.getBoundingClientRect();
            shooterElement.style.left = rect.left + CANVAS_WIDTH / 2 - shooterElement.offsetWidth / 2 + 'px';
            shooterElement.style.top = rect.top + SHOOTER_Y - 40 + 'px';
        }
        
        // ====== Î∞úÏÇ¨ Î°úÏßÅ ======

        function shootBubble() {
            if (isGameOver || firedBubble) return;

            const speed = 8;
            currentBubble.vx = speed * Math.cos(aimAngle);
            currentBubble.vy = -speed * Math.sin(aimAngle);

            currentBubble.isFired = true;
            firedBubble = currentBubble;
            
            currentBubble = getRandomBubble(); 
            isShooting = true;
        }

        // ====== 1. ÏûêÎèô ÏôïÎ≥µ Ï°∞Ï§Ä Î°úÏßÅ ======

        function updateAimAngle() {
            // Í∞ÅÎèÑ Î≥ÄÍ≤Ω
            aimAngle += angleDirection * AIM_SPEED;

            // Í≤ΩÍ≥Ñ Ï°∞Í±¥ ÌôïÏù∏ Î∞è Î∞©Ìñ• Ï†ÑÌôò
            if (aimAngle > MAX_ANGLE) {
                aimAngle = MAX_ANGLE;
                angleDirection = -1; // ÏôºÏ™ΩÏúºÎ°ú Ï†ÑÌôò
            } else if (aimAngle < MIN_ANGLE) {
                aimAngle = MIN_ANGLE;
                angleDirection = 1; // Ïò§Î•∏Ï™ΩÏúºÎ°ú Ï†ÑÌôò
            }
        }

        function drawAimLine() {
            if (firedBubble) return;

            const length = 100; 
            const targetX = currentBubble.x + length * Math.cos(aimAngle);
            const targetY = currentBubble.y - length * Math.sin(aimAngle); 
            
            // ÌôîÏÇ¥Ìëú Ïä§ÌÉÄÏùº
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]); 

            ctx.beginPath();
            ctx.moveTo(currentBubble.x, currentBubble.y);
            ctx.lineTo(targetX, targetY);
            ctx.stroke();
            ctx.setLineDash([]); 
        }
        
        // ====== Í≤åÏûÑ Î°úÏßÅ (Ï∂©Îèå, Í≥†Ï†ï, Ï†úÍ±∞ Îì±ÏùÄ Ïù¥Ï†Ñ ÏΩîÎìúÏôÄ ÎèôÏùº) ======
        
        function checkGridCollision(bubble) {
            if (bubble.y - BUBBLE_RADIUS <= 0) return true;
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < bubbleGrid[r].length; c++) {
                    const target = bubbleGrid[r][c];
                    if (target) {
                        const distance = Math.sqrt((bubble.x - target.x) ** 2 + (bubble.y - target.y) ** 2);
                        if (distance < BUBBLE_RADIUS * 2) return true;
                    }
                }
            }
            return false;
        }

        function snapBubbleToGrid(bubble) {
            const r = Math.round((bubble.y - BUBBLE_RADIUS) / ROW_HEIGHT);
            const cFloat = (bubble.x - BUBBLE_RADIUS) / (BUBBLE_RADIUS * 2) - (r % 2 === 1 ? 0.5 : 0);
            let c = Math.round(cFloat);

            if (r < 0) r = 0;
            if (r >= GRID_ROWS) r = GRID_ROWS - 1; 

            const colsInRow = GRID_COLS - (r % 2);
            if (c < 0) c = 0;
            if (c >= colsInRow) c = colsInRow - 1;
            
            const offsetX = (r % 2 === 1) ? BUBBLE_RADIUS : 0;
            bubble.x = c * BUBBLE_RADIUS * 2 + BUBBLE_RADIUS + offsetX;
            bubble.y = r * ROW_HEIGHT + BUBBLE_RADIUS;
            
            if (bubbleGrid[r] && bubbleGrid[r][c] === null) {
                bubbleGrid[r][c] = bubble;
            } else {
                bubbleGrid[r][c] = bubble; 
            }
            
            firedBubble = null;
            isShooting = false;
            checkAndClearMatches(r, c);
        }

        function findNeighbors(r, c) {
            const isOddRow = r % 2 !== 0; 
            const offsets = isOddRow ? [[-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0], [1, 1]] : [[-1, -1], [-1, 0], [0, -1], [0, 1], [1, -1], [1, 0]];
            const neighbors = [];
            offsets.forEach(([dr, dc]) => {
                const nr = r + dr;
                const nc = c + dc;
                if (nr >= 0 && nr < GRID_ROWS && nc >= 0 && nc < bubbleGrid[nr].length) {
                    if (bubbleGrid[nr][nc]) {
                        neighbors.push({ r: nr, c: nc, bubble: bubbleGrid[nr][nc] });
                    }
                }
            });
            return neighbors;
        }

        function getConnectedBubbles(startR, startC, targetColor) {
            const queue = [{ r: startR, c: startC }];
            const visited = new Set();
            const connected = [];

            while (queue.length > 0) {
                const { r, c } = queue.shift();
                const key = `${r},${c}`;
                if (visited.has(key)) continue;
                visited.add(key);
                const bubble = bubbleGrid[r][c];
                if (bubble && bubble.color === targetColor) {
                    connected.push({ r, c });
                    findNeighbors(r, c).forEach(neighbor => {
                        if (!visited.has(`${neighbor.r},${neighbor.c}`) && neighbor.bubble.color === targetColor) {
                            queue.push({ r: neighbor.r, c: neighbor.c });
                        }
                    });
                }
            }
            return connected;
        }

        function checkAndClearMatches(r, c) {
            const startBubble = bubbleGrid[r][c];
            if (!startBubble) return;

            const connected = getConnectedBubbles(r, c, startBubble.color);
            
            if (connected.length >= 3) {
                connected.forEach(({ r, c }) => { bubbleGrid[r][c] = null; });
                score += connected.length * 10; 
                clearFloatingBubbles();
            }
            checkGameOver();
        }

        function clearFloatingBubbles() {
            const connectedToTop = new Set();
            for (let c = 0; c < bubbleGrid[0].length; c++) {
                if (bubbleGrid[0][c]) {
                    const queue = [{ r: 0, c: c }];
                    const visited = new Set();
                    while (queue.length > 0) {
                        const { r, c } = queue.shift();
                        const key = `${r},${c}`;
                        if (visited.has(key)) continue;
                        visited.add(key);
                        if (r >= 0 && r < GRID_ROWS && c >= 0 && c < bubbleGrid[r].length && bubbleGrid[r][c]) {
                            connectedToTop.add(key);
                            findNeighbors(r, c).forEach(neighbor => {
                                if (!visited.has(`${neighbor.r},${neighbor.c}`)) {
                                    queue.push({ r: neighbor.r, c: neighbor.c });
                                }
                            });
                        }
                    }
                }
            }

            let floatersRemoved = 0;
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < bubbleGrid[r].length; c++) {
                    const key = `${r},${c}`;
                    if (bubbleGrid[r][c] && !connectedToTop.has(key)) {
                        bubbleGrid[r][c] = null;
                        floatersRemoved++;
                    }
                }
            }
            
            if (floatersRemoved > 0) {
                score += floatersRemoved * 50; 
                messageDisplay.textContent = `ÏΩ§Î≥¥! ${floatersRemoved}Í∞úÏùò Î≤ÑÎ∏îÏù¥ Îñ®Ïñ¥Ï°åÏäµÎãàÎã§.`;
            } else {
                messageDisplay.textContent = "";
            }
        }

        function checkGameOver() {
            const maxR = Math.floor(SHOOTER_Y / ROW_HEIGHT);
            if (bubbleGrid.some((row, r) => r > maxR && row.some(b => b !== null))) {
                isGameOver = true;
                messageDisplay.textContent = "Í≤åÏûÑ Ïò§Î≤Ñ! Îã§Ïãú ÏãúÏûëÌïòÎ†§Î©¥ Î≤ÑÌäºÏùÑ ÎàÑÎ•¥ÏÑ∏Ïöî.";
            } else if (bubbleGrid.every(row => row.every(b => b === null))) {
                isGameOver = true;
                messageDisplay.textContent = "‚òÖ ÏäπÎ¶¨! Ï∂ïÌïòÌï©ÎãàÎã§! ‚òÖ";
            }
        }

        function handleFiredBubbleCollision() {
            if (!firedBubble) return;

            if (firedBubble.x - BUBBLE_RADIUS < 0 || firedBubble.x + BUBBLE_RADIUS > CANVAS_WIDTH) {
                firedBubble.vx *= -1;
            }

            if (firedBubble.y - BUBBLE_RADIUS <= 0 || checkGridCollision(firedBubble)) {
                snapBubbleToGrid(firedBubble);
            }
        }

        function drawGrid() {
            let activeRows = 0;
            for (let r = 0; r < GRID_ROWS; r++) {
                if (bubbleGrid[r].some(b => b !== null)) {
                    activeRows++;
                }
                for (let c = 0; c < bubbleGrid[r].length; c++) {
                    const bubble = bubbleGrid[r][c];
                    if (bubble) {
                        bubble.draw();
                    }
                }
            }
            remainingRowsDisplay.textContent = activeRows;
        }

        // ====== Í≤åÏûÑ Î£®ÌîÑ ======

        function draw() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            if (isGameOver) {
                // Í≤åÏûÑ Ïò§Î≤Ñ ÏÉÅÌÉúÏóêÏÑúÎäî Ï°∞Ï§ÄÏÑ† ÏõÄÏßÅÏûÑ Ï§ëÏßÄ
                gameLoop = requestAnimationFrame(draw); 
                return;
            }

            updateAimAngle(); // 1. ÏûêÎèô ÏôïÎ≥µ Î°úÏßÅ Ïã§Ìñâ

            currentBubble.draw();
            
            if (firedBubble) {
                firedBubble.update();
                firedBubble.draw();
                handleFiredBubbleCollision(); 
            } else {
                drawAimLine(); // Î∞úÏÇ¨ Ï§ëÏù¥ ÏïÑÎãê ÎïåÎßå ÌôîÏÇ¥Ìëú ÌëúÏãú
            }

            drawGrid();
            scoreDisplay.textContent = score;

            gameLoop = requestAnimationFrame(draw); 
        }

        // ====== Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà ======
        
        // PC ÌÇ§Î≥¥Îìú Ïù¥Î≤§Ìä∏ (Ïä§ÌéòÏù¥Ïä§Î∞îÎ°ú Î∞úÏÇ¨)
        document.addEventListener('keydown', (e) => {
            if (isGameOver) {
                if (e.key === ' ') startGame();
                return;
            }
            if (e.key === ' ' || e.key === 'Enter') {
                shootBubble();
            }
        });
        
        // 2. Î™®Î∞îÏùº Î∞úÏÇ¨ Î≤ÑÌäº Ïù¥Î≤§Ìä∏
        shootButton.addEventListener('click', () => {
            if (isGameOver) {
                startGame();
            } else {
                shootBubble();
            }
        });

        // Ï∫îÎ≤ÑÏä§ ÌÑ∞Ïπò Ïù¥Î≤§Ìä∏ (Í≤åÏûÑ Ïò§Î≤Ñ Ïãú Ïû¨ÏãúÏûë Î™©Ï†Å)
        canvas.addEventListener('click', () => {
            if (isGameOver) {
                startGame();
            }
        });
        
        // Ï¥àÍ∏∞ Ïã§Ìñâ:
        window.addEventListener('resize', updateShooterPosition);
        startGame();
    </script>
</body>
</html>
