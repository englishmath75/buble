<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ì„¸ë ¨ëœ ë²„ë¸” ìŠˆí„°</title>
    <style>
        /* ê¸°ë³¸ ìŠ¤íƒ€ì¼ */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #1f4287, #21e4c7); /* ë°°ê²½ ê·¸ë¼ë°ì´ì…˜ */
            flex-direction: column;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; 
            padding: 10px;
        }

        #game-wrapper {
            background-color: #0d2c55; /* ì–´ë‘ìš´ ê²Œì„ ë°°ê²½ */
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), 0 0 10px rgba(255, 255, 255, 0.1);
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 420px; /* í™”ë©´ ìµœëŒ€ í¬ê¸° ì œí•œ */
        }

        /* 1. í™”ë©´ í¬ê¸° ì¡°ì •: ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ ì¤„ì´ê³ , Wrapperë¡œ ì „ì²´ë¥¼ ê°ì‹¸ ìì—°ìŠ¤ëŸ½ê²Œ ì¤‘ì•™ ë°°ì¹˜ */
        canvas {
            border: 4px solid #4a90e2; 
            background-color: #1a4e7e; /* ìº”ë²„ìŠ¤ ë°°ê²½ìƒ‰ ì¡°ì • */
            cursor: pointer;
            border-radius: 8px;
            /* ìº”ë²„ìŠ¤ í¬ê¸° ì¶•ì†Œ */
            width: 380px; 
            height: 570px; 
            margin-bottom: 15px;
        }
        
        /* 2. ì„¸ë ¨ëœ í™”ë©´ êµ¬ì„±: ì •ë³´ íŒ¨ë„ ìŠ¤íƒ€ì¼ë§ */
        #info {
            color: #ffffff;
            margin-bottom: 10px;
            font-size: 1.1em;
            font-weight: 600;
            width: 100%;
            text-align: center;
            background-color: #0b3a6d;
            padding: 8px 0;
            border-radius: 5px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        #message {
            color: #ffeb3b;
            font-size: 1.2em;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }

        /* 3. ê±°ë¶ì´ ë°œì‚¬ëŒ€ ìŠ¤íƒ€ì¼ë§ (CSSë§Œìœ¼ë¡œëŠ” ì´ë¯¸ì§€ë¥¼ ëŒ€ì²´í•˜ê¸° ì–´ë ¤ìš°ë¯€ë¡œ í…ìŠ¤íŠ¸ë¡œ ëŒ€ì²´) */
        #shooter {
            position: absolute;
            z-index: 10;
            color: #38c172; /* ê±°ë¶ì´ ìƒ‰ìƒ */
            font-size: 3em;
            text-shadow: 1px 1px 3px #000;
            pointer-events: none; /* í´ë¦­ ì´ë²¤íŠ¸ê°€ ìº”ë²„ìŠ¤ë¡œ ì „ë‹¬ë˜ë„ë¡ ì„¤ì • */
        }
    </style>
</head>
<body>
    <div id="game-wrapper">
        <div id="info">
            ì ìˆ˜: <span id="score">0</span> | ë‚¨ì€ í–‰: <span id="remainingRows"></span>
            <div id="message">ë²„ë¸” ìŠˆí„° ì‹œì‘!</div>
        </div>
        
        <canvas id="gameCanvas" width="400" height="600"></canvas>
        
        <div id="shooter">ğŸ¢</div> 
    </div>

    <script>
        // HTML ìš”ì†Œ ë° Canvas ì»¨í…ìŠ¤íŠ¸
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const remainingRowsDisplay = document.getElementById('remainingRows');
        const messageDisplay = document.getElementById('message');
        const shooterElement = document.getElementById('shooter'); // ê±°ë¶ì´ DOM ìš”ì†Œ

        // ====== ìƒìˆ˜ ë° ì„¤ì • ======
        const CANVAS_WIDTH = 400; // HTMLì—ì„œ ì„¤ì •í•œ ë„ˆë¹„ì™€ ë™ì¼í•˜ê²Œ ìœ ì§€
        const CANVAS_HEIGHT = 600; // HTMLì—ì„œ ì„¤ì •í•œ ë†’ì´ì™€ ë™ì¼í•˜ê²Œ ìœ ì§€
        const BUBBLE_RADIUS = 20; 
        const BUBBLE_COLORS = ['#ff4c4c', '#4caf50', '#2196f3', '#ffeb3b', '#9c27b0']; // ì„¸ë ¨ëœ ìƒ‰ìƒ
        const SHOOTER_Y = CANVAS_HEIGHT - BUBBLE_RADIUS * 2;
        const GRID_ROWS = 15; 
        const GRID_COLS = 10; 
        const ROW_HEIGHT = Math.sqrt(3) * BUBBLE_RADIUS; 
        
        // 1. í™”ì‚´í‘œ ë°©í–¥ ì¡°ì ˆì„ ìœ„í•œ ë³€ìˆ˜
        let aimAngle = Math.PI / 2; // ì´ˆê¸° ê°ë„ (90ë„, ìœ„ìª½)
        const AIM_SPEED = 0.05; // ë°©í–¥ ì¡°ì • ì†ë„

        // ====== ì „ì—­ ë³€ìˆ˜ ======
        let score = 0;
        let isGameOver = false;
        let currentBubble;
        let firedBubble = null;
        let bubbleGrid = [];
        let gameLoop;
        let aimLeft = false; // ë°©í–¥í‚¤ ìƒíƒœ
        let aimRight = false;
        let isShooting = false; // ë°œì‚¬ ì¤‘ ìƒíƒœ

        // ====== í´ë˜ìŠ¤ ì •ì˜: Bubble (ì´ì „ê³¼ ë™ì¼) ======
        class Bubble {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.radius = BUBBLE_RADIUS;
                this.color = color;
                this.vx = 0;
                this.vy = 0;
                this.isFired = false;
                this.isMatched = false;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                
                // ë¸”ë¡ì— í•˜ì´ë¼ì´íŠ¸ ì¶”ê°€í•˜ì—¬ ì„¸ë ¨ë˜ê²Œ ë³´ì´ê²Œ í•¨
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.closePath();
            }

            update() {
                if (this.isFired) {
                    this.x += this.vx;
                    this.y += this.vy;
                }
            }
        }
        
        // ====== ê²Œì„ ì´ˆê¸°í™” ë° ê·¸ë¦¬ë“œ ì„¤ì • (ì´ì „ê³¼ ë™ì¼) ======
        
        function getRandomColor(availableColors) {
            return availableColors[Math.floor(Math.random() * availableColors.length)];
        }
        
        function getRandomBubble() {
            let activeColors = new Set();
            bubbleGrid.forEach(row => {
                row.forEach(b => {
                    if (b) activeColors.add(b.color);
                });
            });
            let colorsArray = Array.from(activeColors.size > 0 ? activeColors : BUBBLE_COLORS);

            const randomColor = getRandomColor(colorsArray);
            return new Bubble(CANVAS_WIDTH / 2, SHOOTER_Y, randomColor);
        }

        function initGrid() {
            bubbleGrid = [];
            for (let r = 0; r < GRID_ROWS; r++) {
                bubbleGrid[r] = [];
                const offsetX = (r % 2 === 1) ? BUBBLE_RADIUS : 0; 
                const colsInRow = GRID_COLS - (r % 2);
                
                for (let c = 0; c < colsInRow; c++) {
                    const x = c * BUBBLE_RADIUS * 2 + BUBBLE_RADIUS + offsetX;
                    const y = r * ROW_HEIGHT + BUBBLE_RADIUS;

                    if (r < 5) { 
                        const randomColor = getRandomColor(BUBBLE_COLORS.slice(0, 4)); 
                        bubbleGrid[r][c] = new Bubble(x, y, randomColor);
                    } else {
                        bubbleGrid[r][c] = null;
                    }
                }
            }
        }

        function startGame() {
            cancelAnimationFrame(gameLoop);
            score = 0;
            isGameOver = false;
            firedBubble = null;
            messageDisplay.textContent = "ë°©í–¥í‚¤(â†, â†’)ë¡œ ì¡°ì¤€ í›„ ìŠ¤í˜ì´ìŠ¤ë°”(ëª¨ë°”ì¼ í„°ì¹˜)ë¡œ ë°œì‚¬í•˜ì„¸ìš”!";

            initGrid();
            currentBubble = getRandomBubble();
            scoreDisplay.textContent = score;
            
            // 3. ê±°ë¶ì´ ë°œì‚¬ëŒ€ ìœ„ì¹˜ ì„¤ì •
            updateShooterPosition();
            
            requestAnimationFrame(draw);
        }
        
        // 3. ê±°ë¶ì´ ë°œì‚¬ëŒ€ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
        function updateShooterPosition() {
            // ê±°ë¶ì´ë¥¼ ìº”ë²„ìŠ¤ ì¤‘ì•™ í•˜ë‹¨ì— ë°°ì¹˜
            shooterElement.style.left = canvas.offsetLeft + CANVAS_WIDTH / 2 - shooterElement.offsetWidth / 2 + 'px';
            shooterElement.style.top = canvas.offsetTop + SHOOTER_Y - 40 + 'px'; // ê±°ë¶ì´ í¬ê¸° ê³ ë ¤í•˜ì—¬ ì¡°ì •
        }
        
        // ====== ë°œì‚¬ ë¡œì§ ======

        function shootBubble() {
            if (isGameOver || firedBubble) return;

            // 1. ê°ë„ë¥¼ ì†ë„ë¡œ ë³€í™˜ (ì§ì ‘ ê°ë„ ì‚¬ìš©)
            const speed = 8;
            currentBubble.vx = speed * Math.cos(aimAngle);
            currentBubble.vy = -speed * Math.sin(aimAngle); // Canvas Yì¶•ì€ ì•„ë˜ë¡œ ì¦ê°€í•˜ë¯€ë¡œ ë§ˆì´ë„ˆìŠ¤

            currentBubble.isFired = true;
            firedBubble = currentBubble;
            
            currentBubble = getRandomBubble(); 
            isShooting = true;
        }

        // ====== 1. ë°©í–¥ í™”ì‚´í‘œ ê·¸ë¦¬ê¸° ë¡œì§ ======

        function drawAimLine() {
            if (firedBubble) return;

            // í™”ì‚´í‘œ ê¸¸ì´
            const length = 100; 
            
            // ëª©í‘œ ì§€ì  ê³„ì‚°
            const targetX = currentBubble.x + length * Math.cos(aimAngle);
            const targetY = currentBubble.y - length * Math.sin(aimAngle); 
            
            // í™”ì‚´í‘œ ìŠ¤íƒ€ì¼
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]); // ì ì„ 

            ctx.beginPath();
            ctx.moveTo(currentBubble.x, currentBubble.y);
            ctx.lineTo(targetX, targetY);
            ctx.stroke();
            ctx.setLineDash([]); // ì ì„  í•´ì œ
        }
        
        // ====== ê²Œì„ ë¡œì§ (ì¶©ëŒ, ê³ ì •, ì œê±°, ê·¸ë¦¬ê¸° ë“±ì€ ì´ì „ ì½”ë“œì™€ ë™ì¼) ======

        function checkGridCollision(bubble) {
            if (bubble.y - BUBBLE_RADIUS <= 0) {
                return true;
            }
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < bubbleGrid[r].length; c++) {
                    const target = bubbleGrid[r][c];
                    if (target) {
                        const distance = Math.sqrt((bubble.x - target.x) ** 2 + (bubble.y - target.y) ** 2);
                        if (distance < BUBBLE_RADIUS * 2) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function snapBubbleToGrid(bubble) {
            const r = Math.round((bubble.y - BUBBLE_RADIUS) / ROW_HEIGHT);
            const cFloat = (bubble.x - BUBBLE_RADIUS) / (BUBBLE_RADIUS * 2) - (r % 2 === 1 ? 0.5 : 0);
            let c = Math.round(cFloat);

            if (r < 0) r = 0;
            if (r >= GRID_ROWS) r = GRID_ROWS - 1; 

            const colsInRow = GRID_COLS - (r % 2);
            if (c < 0) c = 0;
            if (c >= colsInRow) c = colsInRow - 1;
            
            const offsetX = (r % 2 === 1) ? BUBBLE_RADIUS : 0;
            bubble.x = c * BUBBLE_RADIUS * 2 + BUBBLE_RADIUS + offsetX;
            bubble.y = r * ROW_HEIGHT + BUBBLE_RADIUS;
            
            if (bubbleGrid[r] && bubbleGrid[r][c] === null) {
                bubbleGrid[r][c] = bubble;
            } else {
                bubbleGrid[r][c] = bubble; 
            }
            
            firedBubble = null;
            isShooting = false;
            checkAndClearMatches(r, c);
        }

        function findNeighbors(r, c) {
            // ... (ì´ì›ƒ ì°¾ëŠ” ë¡œì§ì€ ìƒëµ. ì›ë³¸ ì½”ë“œë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©)
            const isOddRow = r % 2 !== 0; 
            const offsets = isOddRow ? [[-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0], [1, 1]] : [[-1, -1], [-1, 0], [0, -1], [0, 1], [1, -1], [1, 0]];
            const neighbors = [];
            offsets.forEach(([dr, dc]) => {
                const nr = r + dr;
                const nc = c + dc;
                if (nr >= 0 && nr < GRID_ROWS && nc >= 0 && nc < bubbleGrid[nr].length) {
                    if (bubbleGrid[nr][nc]) {
                        neighbors.push({ r: nr, c: nc, bubble: bubbleGrid[nr][nc] });
                    }
                }
            });
            return neighbors;
        }

        function getConnectedBubbles(startR, startC, targetColor) {
            const queue = [{ r: startR, c: startC }];
            const visited = new Set();
            const connected = [];

            while (queue.length > 0) {
                const { r, c } = queue.shift();
                const key = `${r},${c}`;

                if (visited.has(key)) continue;
                visited.add(key);

                const bubble = bubbleGrid[r][c];
                if (bubble && bubble.color === targetColor) {
                    connected.push({ r, c });

                    findNeighbors(r, c).forEach(neighbor => {
                        if (!visited.has(`${neighbor.r},${neighbor.c}`) && 
                            neighbor.bubble.color === targetColor) {
                            queue.push({ r: neighbor.r, c: neighbor.c });
                        }
                    });
                }
            }
            return connected;
        }

        function checkAndClearMatches(r, c) {
            const startBubble = bubbleGrid[r][c];
            if (!startBubble) return;

            const connected = getConnectedBubbles(r, c, startBubble.color);
            
            if (connected.length >= 3) {
                connected.forEach(({ r, c }) => { bubbleGrid[r][c] = null; });
                score += connected.length * 10; 
                clearFloatingBubbles();
            }
            checkGameOver();
        }

        function clearFloatingBubbles() {
            // ... (ê³ ì•„ ë²„ë¸” ì œê±° ë¡œì§ì€ ìƒëµ. ì›ë³¸ ì½”ë“œë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©)
            const connectedToTop = new Set();
            for (let c = 0; c < bubbleGrid[0].length; c++) {
                if (bubbleGrid[0][c]) {
                    const queue = [{ r: 0, c: c }];
                    const visited = new Set();
                    while (queue.length > 0) {
                        const { r, c } = queue.shift();
                        const key = `${r},${c}`;
                        if (visited.has(key)) continue;
                        visited.add(key);
                        if (r >= 0 && r < GRID_ROWS && c >= 0 && c < bubbleGrid[r].length && bubbleGrid[r][c]) {
                            connectedToTop.add(key);
                            findNeighbors(r, c).forEach(neighbor => {
                                if (!visited.has(`${neighbor.r},${neighbor.c}`)) {
                                    queue.push({ r: neighbor.r, c: neighbor.c });
                                }
                            });
                        }
                    }
                }
            }

            let floatersRemoved = 0;
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < bubbleGrid[r].length; c++) {
                    const key = `${r},${c}`;
                    if (bubbleGrid[r][c] && !connectedToTop.has(key)) {
                        bubbleGrid[r][c] = null;
                        floatersRemoved++;
                    }
                }
            }
            
            if (floatersRemoved > 0) {
                score += floatersRemoved * 50; 
                messageDisplay.textContent = `ì½¤ë³´! ${floatersRemoved}ê°œì˜ ë²„ë¸”ì´ ë–¨ì–´ì¡ŒìŠµë‹ˆë‹¤.`;
            }
        }

        function checkGameOver() {
            const maxR = Math.floor(SHOOTER_Y / ROW_HEIGHT);
            if (bubbleGrid.some((row, r) => r > maxR && row.some(b => b !== null))) {
                isGameOver = true;
                messageDisplay.textContent = "ê²Œì„ ì˜¤ë²„! ë‹¤ì‹œ ì‹œì‘í•˜ë ¤ë©´ í´ë¦­/í„°ì¹˜í•˜ì„¸ìš”.";
            } else if (bubbleGrid.every(row => row.every(b => b === null))) {
                isGameOver = true;
                messageDisplay.textContent = "â˜… ìŠ¹ë¦¬! ì¶•í•˜í•©ë‹ˆë‹¤! â˜…";
            }
        }

        function handleFiredBubbleCollision() {
            if (!firedBubble) return;

            // ì¢Œìš° ë²½ ì¶©ëŒ ì²˜ë¦¬
            if (firedBubble.x - BUBBLE_RADIUS < 0 || firedBubble.x + BUBBLE_RADIUS > CANVAS_WIDTH) {
                firedBubble.vx *= -1;
            }

            // ì²œì¥/ê·¸ë¦¬ë“œ ë²„ë¸” ì¶©ëŒ ì²˜ë¦¬
            if (firedBubble.y - BUBBLE_RADIUS <= 0 || checkGridCollision(firedBubble)) {
                snapBubbleToGrid(firedBubble);
            }
        }

        function drawGrid() {
            let activeRows = 0;
            for (let r = 0; r < GRID_ROWS; r++) {
                if (bubbleGrid[r].some(b => b !== null)) {
                    activeRows++;
                }
                for (let c = 0; c < bubbleGrid[r].length; c++) {
                    const bubble = bubbleGrid[r][c];
                    if (bubble) {
                        bubble.draw();
                    }
                }
            }
            remainingRowsDisplay.textContent = activeRows;
        }

        // 1. ë°©í–¥ ì¡°ì • ë¡œì§
        function updateAimAngle() {
            if (aimLeft) {
                aimAngle += AIM_SPEED;
            } else if (aimRight) {
                aimAngle -= AIM_SPEED;
            }

            // ê°ë„ ì œí•œ (0ë„ ~ 180ë„)
            if (aimAngle > Math.PI) aimAngle = Math.PI;
            if (aimAngle < 0) aimAngle = 0;
        }


        // ====== ê²Œì„ ë£¨í”„ ======

        function draw() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            if (isGameOver) {
                return;
            }

            updateAimAngle(); // ë°©í–¥í‚¤ì— ë”°ë¼ ê°ë„ ì—…ë°ì´íŠ¸

            // 1. ë°œì‚¬ëŒ€ ë²„ë¸” ê·¸ë¦¬ê¸°
            currentBubble.draw();
            
            // 2. ë°œì‚¬ëœ ë²„ë¸” ê·¸ë¦¬ê¸° ë° ì—…ë°ì´íŠ¸
            if (firedBubble) {
                firedBubble.update();
                firedBubble.draw();
                handleFiredBubbleCollision(); 
            } else {
                drawAimLine(); // ë°œì‚¬ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ í™”ì‚´í‘œ í‘œì‹œ
            }

            // 3. ê³ ì •ëœ ë²„ë¸” ê·¸ë¦¬ë“œ ê·¸ë¦¬ê¸°
            drawGrid();
            
            gameLoop = requestAnimationFrame(draw); 
        }

        // ====== ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ======
        
        // í‚¤ë³´ë“œ ì´ë²¤íŠ¸ (PCì—ì„œ ë°©í–¥ ì¡°ì ˆìš©)
        document.addEventListener('keydown', (e) => {
            if (isGameOver) return;
            if (e.key === 'ArrowLeft' || e.key === 'a') {
                aimLeft = true;
            } else if (e.key === 'ArrowRight' || e.key === 'd') {
                aimRight = true;
            } else if (e.key === ' ' || e.key === 'Enter') {
                shootBubble();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a') {
                aimLeft = false;
            } else if (e.key === 'ArrowRight' || e.key === 'd') {
                aimRight = false;
            }
        });

        // 4. ëª¨ë°”ì¼ í„°ì¹˜ ì´ë²¤íŠ¸ (í™”ë©´ ì¤‘ì•™ í„°ì¹˜ ì‹œ ë°œì‚¬)
        canvas.addEventListener('click', (e) => {
            if (isGameOver) {
                startGame();
                return;
            }
            // ë°œì‚¬ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ ë°œì‚¬
            if (!firedBubble) {
                 shootBubble();
            }
        });

        // ì´ˆê¸° ì‹¤í–‰:
        // window.onload ëŒ€ì‹  ë°”ë¡œ ì‹¤í–‰
        window.addEventListener('resize', updateShooterPosition); // í™”ë©´ í¬ê¸° ë³€ê²½ ì‹œ ê±°ë¶ì´ ìœ„ì¹˜ ì¡°ì •
        startGame();
    </script>
</body>
</html>
